{"version":3,"file":"hexToRgb/script.js","mappings":"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","sources":["webpack://melusc.github.io/./node_modules/hex-rgb/index.js","webpack://melusc.github.io/./node_modules/rgb-hex/index.js","webpack://melusc.github.io/./node_modules/lodash-es/isObject.js","webpack://melusc.github.io/./node_modules/lodash-es/_freeGlobal.js","webpack://melusc.github.io/./node_modules/lodash-es/_root.js","webpack://melusc.github.io/./node_modules/lodash-es/now.js","webpack://melusc.github.io/./node_modules/lodash-es/_trimmedEndIndex.js","webpack://melusc.github.io/./node_modules/lodash-es/_baseTrim.js","webpack://melusc.github.io/./node_modules/lodash-es/_Symbol.js","webpack://melusc.github.io/./node_modules/lodash-es/_getRawTag.js","webpack://melusc.github.io/./node_modules/lodash-es/_objectToString.js","webpack://melusc.github.io/./node_modules/lodash-es/_baseGetTag.js","webpack://melusc.github.io/./node_modules/lodash-es/toNumber.js","webpack://melusc.github.io/./node_modules/lodash-es/isSymbol.js","webpack://melusc.github.io/./node_modules/lodash-es/isObjectLike.js","webpack://melusc.github.io/./node_modules/lodash-es/debounce.js","webpack://melusc.github.io/../src/util.js","webpack://melusc.github.io/../src/options.js","webpack://melusc.github.io/../src/create-element.js","webpack://melusc.github.io/../src/component.js","webpack://melusc.github.io/../src/constants.js","webpack://melusc.github.io/../src/diff/children.js","webpack://melusc.github.io/../src/diff/props.js","webpack://melusc.github.io/../src/diff/index.js","webpack://melusc.github.io/../src/utils/errors.ts","webpack://melusc.github.io/../src/utils/common.ts","webpack://melusc.github.io/../src/utils/plugins.ts","webpack://melusc.github.io/../src/core/scope.ts","webpack://melusc.github.io/../src/core/finalize.ts","webpack://melusc.github.io/../src/core/proxy.ts","webpack://melusc.github.io/../src/core/immerClass.ts","webpack://melusc.github.io/../src/core/current.ts","webpack://melusc.github.io/../src/diff/catch-error.js","webpack://melusc.github.io/../src/immer.ts","webpack://melusc.github.io/../src/utils/env.ts","webpack://melusc.github.io/./node_modules/clsx/dist/clsx.m.js","webpack://melusc.github.io/./src/hexToRgb/util.ts","webpack://melusc.github.io/./src/hexToRgb/script.tsx","webpack://melusc.github.io/../src/render.js"],"sourcesContent":["const hexCharacters = 'a-f\\\\d';\nconst match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;\nconst match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;\nconst nonHexChars = new RegExp(`[^#${hexCharacters}]`, 'gi');\nconst validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, 'i');\n\nexport default function hexRgb(hex, options = {}) {\n\tif (typeof hex !== 'string' || nonHexChars.test(hex) || !validHexSize.test(hex)) {\n\t\tthrow new TypeError('Expected a valid hex string');\n\t}\n\n\thex = hex.replace(/^#/, '');\n\tlet alphaFromHex = 1;\n\n\tif (hex.length === 8) {\n\t\talphaFromHex = Number.parseInt(hex.slice(6, 8), 16) / 255;\n\t\thex = hex.slice(0, 6);\n\t}\n\n\tif (hex.length === 4) {\n\t\talphaFromHex = Number.parseInt(hex.slice(3, 4).repeat(2), 16) / 255;\n\t\thex = hex.slice(0, 3);\n\t}\n\n\tif (hex.length === 3) {\n\t\thex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n\t}\n\n\tconst number = Number.parseInt(hex, 16);\n\tconst red = number >> 16;\n\tconst green = (number >> 8) & 255;\n\tconst blue = number & 255;\n\tconst alpha = typeof options.alpha === 'number' ? options.alpha : alphaFromHex;\n\n\tif (options.format === 'array') {\n\t\treturn [red, green, blue, alpha];\n\t}\n\n\tif (options.format === 'css') {\n\t\tconst alphaString = alpha === 1 ? '' : ` / ${Number((alpha * 100).toFixed(2))}%`;\n\t\treturn `rgb(${red} ${green} ${blue}${alphaString})`;\n\t}\n\n\treturn {red, green, blue, alpha};\n}\n","export default function rgbHex(red, green, blue, alpha) {\n\tconst isPercent = (red + (alpha || '')).toString().includes('%');\n\n\tif (typeof red === 'string') {\n\t\t[red, green, blue, alpha] = red.match(/(0?\\.?\\d{1,3})%?\\b/g).map(component => Number(component));\n\t} else if (alpha !== undefined) {\n\t\talpha = Number.parseFloat(alpha);\n\t}\n\n\tif (typeof red !== 'number' ||\n\t\ttypeof green !== 'number' ||\n\t\ttypeof blue !== 'number' ||\n\t\tred > 255 ||\n\t\tgreen > 255 ||\n\t\tblue > 255\n\t) {\n\t\tthrow new TypeError('Expected three numbers below 256');\n\t}\n\n\tif (typeof alpha === 'number') {\n\t\tif (!isPercent && alpha >= 0 && alpha <= 1) {\n\t\t\talpha = Math.round(255 * alpha);\n\t\t} else if (isPercent && alpha >= 0 && alpha <= 100) {\n\t\t\talpha = Math.round(255 * alpha / 100);\n\t\t} else {\n\t\t\tthrow new TypeError(`Expected alpha value (${alpha}) as a fraction or percentage`);\n\t\t}\n\n\t\talpha = (alpha | 1 << 8).toString(16).slice(1); // eslint-disable-line no-mixed-operators\n\t} else {\n\t\talpha = '';\n\t}\n\n\t// TODO: Remove this ignore comment.\n\t// eslint-disable-next-line no-mixed-operators\n\treturn ((blue | green << 8 | red << 16) | 1 << 24).toString(16).slice(1) + alpha;\n}\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","import root from './_root.js';\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nexport default now;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n","import trimmedEndIndex from './_trimmedEndIndex.js';\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nexport default baseTrim;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","import baseTrim from './_baseTrim.js';\nimport isObject from './isObject.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import isObject from './isObject.js';\nimport now from './now.js';\nimport toNumber from './toNumber.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport default debounce;\n","import { EMPTY_ARR } from \"./constants\";\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-ignore We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\t_hydrating: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original\n\t};\n\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = vnode._original + 1;\n\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tvnode._hydrating != null ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom,\n\t\t\tvnode._hydrating\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (vnode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tnewDom = childVNode._dom;\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\t\tchildVNode._children != null && // Can be null if childVNode suspended\n\t\t\t\tchildVNode._children === oldVNode._children\n\t\t\t) {\n\t\t\t\tchildVNode._nextDom = oldDom = reorderChildren(\n\t\t\t\t\tchildVNode,\n\t\t\t\t\toldDom,\n\t\t\t\t\tparentDom\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tchildVNode,\n\t\t\t\t\toldVNode,\n\t\t\t\t\toldChildren,\n\t\t\t\t\tnewDom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type === 'option') {\n\t\t\t\t// @ts-ignore We have validated that the type of parentDOM is 'option'\n\t\t\t\t// in the above check\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) {\n\t\t\tif (\n\t\t\t\ttypeof newParentVNode.type == 'function' &&\n\t\t\t\toldChildren[i]._dom != null &&\n\t\t\t\toldChildren[i]._dom == newParentVNode._nextDom\n\t\t\t) {\n\t\t\t\t// If the newParentVNode.__nextDom points to a dom node that is about to\n\t\t\t\t// be unmounted, then get the next sibling of that vnode and set\n\t\t\t\t// _nextDom to it\n\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldParentVNode, i + 1);\n\t\t\t}\n\n\t\t\tunmount(oldChildren[i], oldChildren[i]);\n\t\t}\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\nfunction reorderChildren(childVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < childVNode._children.length; tmp++) {\n\t\tlet vnode = childVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\t// We typically enter this code path on sCU bailout, where we copy\n\t\t\t// oldVNode._children to newVNode._children. If that is the case, we need\n\t\t\t// to update the old children's _parent pointer to point to the newVNode\n\t\t\t// (childVNode here).\n\t\t\tvnode._parent = childVNode;\n\n\t\t\tif (typeof vnode.type == 'function') {\n\t\t\t\toldDom = reorderChildren(vnode, oldDom, parentDom);\n\t\t\t} else {\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tchildVNode._children,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nfunction placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\toldVNode == null ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (name.toLowerCase() in dom) name = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\t\tdom.addEventListener(name, handler, useCapture);\n\t\t\t}\n\t\t} else {\n\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\tdom.removeEventListener(name, handler, useCapture);\n\t\t}\n\t} else if (name !== 'dangerouslySetInnerHTML') {\n\t\tif (isSvg) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink[H:h]/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname !== 'href' &&\n\t\t\tname !== 'list' &&\n\t\t\tname !== 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname !== 'tabIndex' &&\n\t\t\tname !== 'download' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t// The value `false` is different from the attribute not\n\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t// that other VDOM frameworks also always stringify `false`.\n\n\t\tif (typeof value === 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (\n\t\t\tvalue != null &&\n\t\t\t(value !== false || (name[0] === 'a' && name[1] === 'r'))\n\t\t) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ } from '../constants';\nimport { Component, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._hydrating != null) {\n\t\tisHydrating = oldVNode._hydrating;\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\t// if we resume, we want the tree to be \"unlocked\"\n\t\tnewVNode._hydrating = null;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\t// @ts-ignore The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.forEach(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._hydrating = null;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\tnewVNode._dom = oldDom;\n\t\t\tnewVNode._hydrating = !!isHydrating;\n\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t// ^ could possibly be simplified to:\n\t\t\t// excessDomChildren.length = 0;\n\t\t}\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-ignore Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-ignore See above ts-ignore on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = newVNode.type;\n\tlet i = 0;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tif (nodeType === 'svg') isSvg = true;\n\n\tif (excessDomChildren != null) {\n\t\tfor (; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild &&\n\t\t\t\t(child === dom ||\n\t\t\t\t\t(nodeType ? child.localName == nodeType : child.nodeType == 3))\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\t// @ts-ignore createTextNode returns Text, we expect PreactElement\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tif (isSvg) {\n\t\t\tdom = document.createElementNS(\n\t\t\t\t'http://www.w3.org/2000/svg',\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\tnodeType\n\t\t\t);\n\t\t} else {\n\t\t\tdom = document.createElement(\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\tnodeType,\n\t\t\t\tnewProps.is && newProps\n\t\t\t);\n\t\t}\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (\n\t\t\t\t\t!newHtml ||\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\n\t\t\t\t) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg && nodeType !== 'foreignObject',\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(i !== dom.value || (nodeType === 'progress' && !i))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(r[i], parentVNode, typeof vnode.type != 'function');\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && vnode._dom != null) removeNode(vnode._dom);\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\trootState: ImmerState,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE],\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumarable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches) as any\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches.slice(i + 1))\n\t\t) as any\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, ctor, handled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","function toVal(mix) {\n\tvar k, y, str='';\n\n\tif (typeof mix === 'string' || typeof mix === 'number') {\n\t\tstr += mix;\n\t} else if (typeof mix === 'object') {\n\t\tif (Array.isArray(mix)) {\n\t\t\tfor (k=0; k < mix.length; k++) {\n\t\t\t\tif (mix[k]) {\n\t\t\t\t\tif (y = toVal(mix[k])) {\n\t\t\t\t\t\tstr && (str += ' ');\n\t\t\t\t\t\tstr += y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (k in mix) {\n\t\t\t\tif (mix[k]) {\n\t\t\t\t\tstr && (str += ' ');\n\t\t\t\t\tstr += k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn str;\n}\n\nexport default function () {\n\tvar i=0, tmp, x, str='';\n\twhile (i < arguments.length) {\n\t\tif (tmp = arguments[i++]) {\n\t\t\tif (x = toVal(tmp)) {\n\t\t\t\tstr && (str += ' ');\n\t\t\t\tstr += x\n\t\t\t}\n\t\t}\n\t}\n\treturn str;\n}\n","const isOfType = <T>(key: unknown, list: readonly T[]): key is T =>\n\tlist.includes(key as T);\n\nexport {isOfType};\n","import type {Except} from 'type-fest';\n\nimport hexRgb from 'hex-rgb';\nimport rgbHex from 'rgb-hex';\n\nimport {debounce} from 'lodash';\n\nimport {render, h, Component, Fragment} from 'preact';\nimport {produce} from 'immer';\nimport clsx from 'clsx';\n\nimport {isOfType} from './util';\n\nconst inputKeys = ['hex', 'red', 'green', 'blue', 'alpha'] as const;\ntype InputKeys = typeof inputKeys[number];\n\ntype Inputs = {\n\t[key in InputKeys]: string;\n};\n\ntype RgbaLabels = keyof Except<Inputs, 'hex'>;\n\ntype AppState = {\n\tinputs: Inputs;\n};\n\nconst Input = (properties: Record<string, unknown>) => (\n\t<>\n\t\t<input {...properties} />\n\t\t<div class=\"input-pseudo-border\" />\n\t</>\n);\n\nconst sanitiseHex = (hex: string, shouldShorten = true): string => {\n\thex = hex.trim();\n\n\t// Remove leading \"#\"\n\thex = `#${hex}`.replace(/^#+/g, '');\n\n\tlet shortFormPossible\n\t\t= shouldShorten && (hex.length === 8 || hex.length === 6);\n\tlet shortForm = '';\n\tfor (let index = 0; index < hex.length && shortFormPossible; index += 2) {\n\t\tif (hex[index] === hex[index + 1]) {\n\t\t\tshortForm += hex[index];\n\t\t} else {\n\t\t\tshortFormPossible = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn `#${shortFormPossible ? shortForm : hex}`;\n};\n\nconst setHashInstantly = (hex: string) => {\n\thex = sanitiseHex(hex);\n\n\tif (hex !== location.hash) {\n\t\t/*\n      https://developer.mozilla.org/en-US/docs/Web/API/History/pushState#description\n      -> history.pushState doesn't trigger hashchange\n\n      Alternative would be storing current hex and location.hash and\n      when setHash updates the hash, the stored hex and hash will be the same\n      and if the user goes back in history the stored hex and hash will not be the same\n    */\n\t\thistory.pushState({}, '', hex);\n\t}\n};\n\n/*\n  To not spam the history\n*/\nconst setHashDebounced = debounce(setHashInstantly, 800, {\n\tleading: true,\n\ttrailing: true,\n\tmaxWait: 1500,\n});\n\nconst rgbaLabels: ReadonlySet<RgbaLabels> = new Set([\n\t'red',\n\t'green',\n\t'blue',\n\t'alpha',\n]);\n\nclass App extends Component<Record<string, unknown>, AppState> {\n\tstate: AppState = {\n\t\tinputs: {\n\t\t\thex: '',\n\t\t\tred: '',\n\t\t\tgreen: '',\n\t\t\tblue: '',\n\t\t\talpha: '',\n\t\t},\n\t};\n\n\tinvalidInputs = new Set<keyof Inputs>();\n\n\trender = () => {\n\t\tconst {invalidInputs, state, randomColour, handleInput, handleScroll}\n\t\t\t= this;\n\t\tconst {inputs} = state;\n\t\tconst {hex, alpha} = inputs;\n\t\tconst labels: Array<keyof Inputs> = ['red', 'green', 'blue'];\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tclass=\"horizontal-vertical-center\"\n\t\t\t\t/*\n          If style is an object preact basically does:\n          style.backgroundColor = value\n          and if hex is '#', Firefox (but not Chromium)\n          doesn't modify the color because the color is\n          invalid.\n\n          So instead we use a string to force invalid colors\n          to be set as well, in which case it will be white instead\n        */\n\t\t\t\tstyle={`background-color:${hex}`}\n\t\t\t>\n\t\t\t\t<div class=\"floating-box\">\n\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t<div>Hex</div>\n\t\t\t\t\t\t<div class=\"inputs-rows\">\n\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\tmaxLength={9}\n\t\t\t\t\t\t\t\tvalue={hex}\n\t\t\t\t\t\t\t\tplaceholder=\"#\"\n\t\t\t\t\t\t\t\tname=\"hex\"\n\t\t\t\t\t\t\t\tclass={clsx({\n\t\t\t\t\t\t\t\t\tinvalid: invalidInputs.has('hex'),\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\tonInput={handleInput}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t<div>Rgba</div>\n\t\t\t\t\t\t<div class=\"inputs-rows\">\n\t\t\t\t\t\t\t{labels.map(key => (\n\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\tkey={key}\n\t\t\t\t\t\t\t\t\ttype=\"number\"\n\t\t\t\t\t\t\t\t\tmin=\"0\"\n\t\t\t\t\t\t\t\t\tmax=\"255\"\n\t\t\t\t\t\t\t\t\tmaxLength={3}\n\t\t\t\t\t\t\t\t\tname={key}\n\t\t\t\t\t\t\t\t\tplaceholder={key}\n\t\t\t\t\t\t\t\t\tvalue={inputs[key]}\n\t\t\t\t\t\t\t\t\tclass={clsx({\n\t\t\t\t\t\t\t\t\t\tinvalid: invalidInputs.has(key),\n\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t\tonInput={handleInput}\n\t\t\t\t\t\t\t\t\tonWheel={handleScroll}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t// [type=\"tel\"] because percent is valid in our use-case\n\t\t\t\t\t\t\t\t// but not valid for [type=\"number\"]\n\t\t\t\t\t\t\t\ttype=\"tel\"\n\t\t\t\t\t\t\t\tmin=\"0\"\n\t\t\t\t\t\t\t\tmax=\"1\"\n\t\t\t\t\t\t\t\tplaceholder=\"[alpha]\"\n\t\t\t\t\t\t\t\tvalue={alpha}\n\t\t\t\t\t\t\t\tname=\"alpha\"\n\t\t\t\t\t\t\t\tclass={clsx({\n\t\t\t\t\t\t\t\t\tinvalid: invalidInputs.has('alpha'),\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\tonInput={handleInput}\n\t\t\t\t\t\t\t\tonWheel={handleScroll}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t<div class=\"rainbow-box\">\n\t\t\t\t\t\t\t<div class=\"rainbow-text\" onClick={randomColour}>\n\t\t\t\t\t\t\t\tRandom colour\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"rainbow-bg\" />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t};\n\n\tcomponentDidMount = () => {\n\t\taddEventListener('hashchange', this.handleHashChange);\n\n\t\t// If there is already a hash\n\t\t// it will be filled in this way\n\t\tthis.handleHashChange();\n\t};\n\n\tcomponentWillUnmount = () => {\n\t\tremoveEventListener('hashchange', this.handleHashChange);\n\t};\n\n\thandleScroll: h.JSX.WheelEventHandler<HTMLInputElement> = event_ => {\n\t\tconst target = event_.currentTarget;\n\n\t\tconst label = target.name;\n\n\t\tconst {inputs} = this.state;\n\n\t\tif (!isOfType(label, inputKeys)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Expected label to be of type inputKeys instead got ${label}.`,\n\t\t\t);\n\t\t}\n\n\t\tconst direction = -Math.sign(event_.deltaY);\n\n\t\tlet value = inputs[label];\n\n\t\tif (typeof value !== 'string') {\n\t\t\treturn;\n\t\t}\n\n\t\tvalue = value.trim();\n\n\t\tif (label === 'alpha') {\n\t\t\tlet multiplier = 100;\n\t\t\tlet endsWith = '';\n\n\t\t\tif (value.endsWith('%')) {\n\t\t\t\tmultiplier = 1;\n\t\t\t\tendsWith = '%';\n\n\t\t\t\tvalue = value.slice(0, -1);\n\t\t\t}\n\n\t\t\tif (Number.isNaN(Number(value))) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet parsed = Number(value) * multiplier;\n\t\t\tparsed += direction;\n\n\t\t\tparsed = parsed > 100 ? 100 : (parsed < 0 ? 0 : parsed);\n\n\t\t\tparsed /= multiplier;\n\n\t\t\tparsed = Math.trunc(parsed * 1e2) / 1e2;\n\n\t\t\tvalue = `${parsed}${endsWith}`;\n\t\t} else {\n\t\t\tif (Number.isNaN(Number(value))) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet parsed = Number(value) + direction;\n\t\t\tparsed = parsed > 255 ? 255 : (parsed < 0 ? 0 : parsed);\n\t\t\tparsed = Math.trunc(parsed * 1e2) / 1e2;\n\n\t\t\tvalue = `${parsed}`;\n\t\t}\n\n\t\tthis.handleRgbaInput(label, value);\n\t};\n\n\thandleHashChange = (event_?: HashChangeEvent) => {\n\t\tlet hex = location.hash;\n\t\thex = sanitiseHex(hex);\n\n\t\tthis.hexSetState(hex);\n\n\t\ttry {\n\t\t\tconst rgba = hexRgb(hex);\n\n\t\t\t// At this point the hex is valid\n\t\t\t// because otherwise the function above\n\t\t\t// would have thrown\n\n\t\t\tthis.rgbaSetState(rgba);\n\n\t\t\tif (event_ === undefined) {\n\t\t\t\t// If called directly instead\n\t\t\t\t// of by the eventlistener\n\t\t\t\tsetHashInstantly(hex);\n\t\t\t}\n\t\t} catch {\n\t\t\tthis.setState(\n\t\t\t\tproduce((state: AppState) => {\n\t\t\t\t\tconst inputs = state.inputs;\n\n\t\t\t\t\tfor (const label of rgbaLabels) {\n\t\t\t\t\t\tinputs[label] = '';\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t};\n\n\trandomColour = () => {\n\t\tconst [red, blue, green] = crypto.getRandomValues(new Uint8Array(3));\n\n\t\tthis.rgbaSetState({\n\t\t\t// These cannot not be a number\n\t\t\tred: red!,\n\t\t\tblue: blue!,\n\t\t\tgreen: green!,\n\t\t\talpha: 1,\n\t\t});\n\n\t\tlet hex = rgbHex(red!, green!, blue!);\n\n\t\thex = sanitiseHex(hex);\n\n\t\tsetHashInstantly(hex);\n\n\t\tthis.hexSetState(hex);\n\t};\n\n\trgbaSetState = (\n\t\trgba: Readonly<{\n\t\t\tred: number;\n\t\t\tgreen: number;\n\t\t\tblue: number;\n\t\t\talpha: number;\n\t\t}>,\n\t) => {\n\t\tthis.setState(\n\t\t\tproduce((state: AppState) => {\n\t\t\t\tconst {inputs} = state;\n\n\t\t\t\tfor (const key of rgbaLabels) {\n\t\t\t\t\tconst value = rgba[key];\n\n\t\t\t\t\tinputs[key] = value.toFixed(Number.isInteger(value) ? 0 : 2);\n\t\t\t\t}\n\n\t\t\t\treturn state;\n\t\t\t}),\n\t\t);\n\t};\n\n\t/**\n\t * It is the caller's responsibility to sanitise the passed\n\t * value because maybe the hex shouldn't be shortened\n\t * or even sanitised\n\t *\n\t * @param {string} hex The hex value to update the state with\n\t *\n\t * @return {void}\n\t */\n\thexSetState = (hex: string) => {\n\t\tthis.setState(\n\t\t\tproduce((state: AppState) => {\n\t\t\t\tstate.inputs.hex = hex;\n\t\t\t}),\n\t\t);\n\t};\n\n\thandleHexInput = (hex: string) => {\n\t\tconst {invalidInputs} = this;\n\n\t\thex = sanitiseHex(hex, false);\n\n\t\tthis.hexSetState(hex);\n\n\t\ttry {\n\t\t\tconst rgba = hexRgb(hex);\n\n\t\t\tsetHashDebounced(hex);\n\t\t\t// Only if the hex was valid (calling hexRgb)\n\n\t\t\tinvalidInputs.delete('hex');\n\n\t\t\tthis.rgbaSetState(rgba);\n\t\t} catch {\n\t\t\tinvalidInputs.add('hex');\n\t\t\tthis.forceUpdate();\n\t\t\t// Force update because invalidInputs won't by itself\n\t\t}\n\t};\n\n\thandleRgbaInput = (label: string, value: string) => {\n\t\tconst {invalidInputs} = this;\n\n\t\tthis.setState(\n\t\t\tproduce((state: AppState) => {\n\t\t\t\tconst {inputs} = state;\n\n\t\t\t\tif (!isOfType(label, inputKeys)) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected label to be of type inputKeys instead got ${label}.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tinputs[label] = value;\n\n\t\t\t\t// The next few lines because if alpha is '', '1' or '100%'\n\t\t\t\t// we want a 6-digit instead\n\t\t\t\t// and we can achieve that by passing undefined\n\n\t\t\t\tlet alpha: string | undefined = inputs.alpha;\n\t\t\t\tif (['1', '100%', ''].includes(alpha)) {\n\t\t\t\t\talpha = undefined;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tlet hex = rgbHex(\n\t\t\t\t\t\tNumber(inputs.red),\n\t\t\t\t\t\tNumber(inputs.green),\n\t\t\t\t\t\tNumber(inputs.blue),\n\t\t\t\t\t\talpha,\n\t\t\t\t\t);\n\n\t\t\t\t\thex = sanitiseHex(hex);\n\n\t\t\t\t\tinputs.hex = hex;\n\n\t\t\t\t\tsetHashDebounced(inputs.hex);\n\n\t\t\t\t\tfor (const label of rgbaLabels) {\n\t\t\t\t\t\tinvalidInputs.delete(label);\n\t\t\t\t\t}\n\n\t\t\t\t\tinvalidInputs.delete('hex');\n\t\t\t\t} catch {\n\t\t\t\t\tinvalidInputs.add(label);\n\t\t\t\t\t// No forceUpdate, will trigger after immer is done\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t};\n\n\thandleInput: h.JSX.GenericEventHandler<HTMLInputElement> = event_ => {\n\t\tconst target = event_.currentTarget;\n\n\t\tconst value = target.value.trim();\n\t\tconst label = target.name;\n\n\t\tif (!isOfType(label, inputKeys)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Expected label to be of type inputKeys instead got ${label}.`,\n\t\t\t);\n\t\t}\n\n\t\tif (label === 'hex') {\n\t\t\tthis.handleHexInput(value);\n\t\t} else if (rgbaLabels.has(label)) {\n\t\t\tthis.handleRgbaInput(label, value);\n\t\t}\n\t};\n}\n\nconst root = document.querySelector<HTMLDivElement>('#root');\nif (root) {\n\trender(<App />, root);\n}\n","import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode === 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = (\n\t\t(!isHydrating && replaceNode) ||\n\t\tparentDom\n\t)._children = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.firstChild\n\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t? oldVNode._dom\n\t\t\t: parentDom.firstChild,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n"],"names":["nonHexChars","RegExp","validHexSize","hexRgb","hex","options","test","TypeError","alphaFromHex","replace","length","Number","parseInt","slice","repeat","number","red","green","blue","alpha","format","toFixed","rgbHex","isPercent","toString","includes","match","map","component","undefined","parseFloat","Math","round","value","type","global","Object","freeSelf","self","freeGlobal","Function","root","reWhitespace","reTrimStart","objectProto","prototype","hasOwnProperty","nativeObjectToString","symToStringTag","Symbol","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","isObjectLike","isOwn","call","tag","unmasked","e","result","getRawTag","objectToString","baseGetTag","isSymbol","isObject","other","valueOf","string","index","charAt","trimmedEndIndex","isBinary","vnodeId","rerenderQueue","defer","prevDebounce","nativeMax","max","nativeMin","min","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","i","removeNode","node","parentNode","removeChild","createElement","children","key","ref","normalizedProps","arguments","defaultProps","createVNode","original","vnode","constructor","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","push","process","debounceRendering","queue","sort","a","b","some","commitQueue","oldVNode","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","newDom","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","reorderChildren","placeChild","unmount","applyRef","tmp","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","setStyle","style","setProperty","dom","name","oldValue","useCapture","o","cssText","toLowerCase","_listeners","addEventListener","eventProxyCapture","eventProxy","removeEventListener","setAttribute","removeAttribute","event","newVNode","isNew","oldProps","oldState","snapshot","clearProcessingException","newProps","provider","componentContext","newType","contextType","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","forEach","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","cb","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","hydrate","diffProps","checked","current","parentVNode","skipRemove","r","componentWillUnmount","this","die","error","args","msg","Error","s","join","isDraft","DRAFT_STATE","isDraftable","proto","getPrototypeOf","Ctor","objectCtorString","DRAFTABLE","isMap","isSet","each","iter","enumerableOnly","getArchtype","keys","ownKeys","entry","thing","type_","has","prop","set","propOrOldValue","t","delete","add","y","target","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","descriptors","getOwnPropertyDescriptors","desc","writable","configurable","get","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","copyHelper","archType","from","ctor","handled","getDerivedStateFromError","setState","componentDidCatch","update","callback","forceUpdate","Promise","then","bind","resolve","setTimeout","hasSymbol","hasProxies","Reflect","for","iterator","getOwnPropertySymbols","getOwnPropertyNames","currentState","x","deleteProperty","owner","defineProperty","setPrototypeOf","fn","apply","config","recipe","defaultBase","_this","produce","_this2","hasError","arg1","arg2","produceWithPatches","p","ip","patches","inversePatches","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","currentImpl","copy","hasChanges_","finishDraft","applyPatches","patch","op","applyPatchesImpl","applyPatches_","toVal","mix","k","str","isOfType","list","inputKeys","Input","properties","class","sanitiseHex","shouldShorten","trim","shortFormPossible","shortForm","setHashInstantly","location","hash","history","pushState","setHashDebounced","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","invokeFunc","time","thisArg","leadingEdge","timerExpired","shouldInvoke","timeSinceLastCall","now","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","clearTimeout","toNumber","cancel","flush","rgbaLabels","querySelector","firstChild","inputs","invalidInputs","randomColour","handleInput","handleScroll","maxLength","placeholder","invalid","onInput","onWheel","onClick","handleHashChange","event_","label","currentTarget","direction","sign","deltaY","multiplier","endsWith","isNaN","parsed","trunc","handleRgbaInput","hexSetState","rgba","rgbaSetState","crypto","getRandomValues","Uint8Array","isInteger","handleHexInput"],"sourceRoot":""}